# 头文件
```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
using ull = unsigned long long;
#define IOSclose cin.tie(0)->sync_with_stdio(0),cout.tie(0)
#define all(a) a.begin(),a.end()
#define endl '\n'

int main()
{
	#ifdef ONLINE_JUDGE
	IOSclose;
	#endif
	
	cout<<"hello,world!"<<endl;
	
	#ifndef ONLINE_JUDGE
	cout<<endl;
	system("pause");
	#endif

	return 0;
}
```

# 一些零散的算法
## 快速幂

递归写法
```cpp
int FastPow(int base,int index,int mod)
{
    if(index==0)return 1;
    if(index==1)return base;
    int half=FastPow(base,index/2,mod);
    return (index&1?base:1)*half*half;
}
```
循环写法
```cpp
int mypow(int n, int k, int p)
{
    int r = 1;
    for (; k; k >>= 1, n = n * n % p) {
        if (k & 1) r = r * n % p;
    }
    return r;
}
```
## 二分
```cpp
int dichotomy(int l,int r,int goal)
{
    int ret=-1;
    while(l<=r)
    {
        int mid=(l+r)>>1;
        if(Array[mid]>=goal)
            ret=mid,r=mid-1;
        else
            l=mid+1;
        // if(Array[mid]<=goal)
            // ret=mid,l=mid+1;
        // else
            // r=mid-1;
    }
    return ret;
}
```
## ~~没什么吊用的闰年判断~~
```cpp
bool LeapYear(int year)
{
    return year%4==0&&(year%400==0||!(year%400!=0&&year%100==0));
}
```
# 数论
## 筛质数
埃氏筛
```cpp
vector<bool> prime(n,1);
void is_prime( int n )
{
    prime[0] = prime[1] = 0;

    for ( int i = 2 ; i*i <= n ; i++ )
    {
        if ( prime[i] )
        {
            for ( int j = 2 ; i*j <= n ; j++ )
            {
                prime[i*j] = 0 ;
            }
        }
    }
}
```
欧拉筛
```cpp
vector<int> prime; // 这里储存筛出来的全部质数
auto euler_Prime = [&](int n) -> void {
    vector<int> v(n + 1);
    for (int i = 2; i <= n; ++i)
    {
        if (!v[i]) 
        {
            v[i] = i;
            prime.push_back(i);
        }
        for (int j = 0; j < prime.size(); ++j)
        {
            if (prime[j] > v[i] || prime[j] > n / i) break;
            v[i * prime[j]] = prime[j];
        }
    }
};
```
# 字符串
## KMP搜索字符串子串
```cpp
int kmp(string text, string pattern) {
    int n = text.size(), m = pattern.size();
    if (m == 0) {
        return 0;
    }
    vector<int> next(m);
    for (int i = 1, j = 0; i < m; i++) {
        while (j > 0 && pattern[i] != pattern[j]) {
            j = next[j - 1];
        }
        if (pattern[i] == pattern[j]) {
            j++;
        }
        next[i] = j;
    }
    for (int i = 0, j = 0; i < n; i++) {
        while (j > 0 && text[i] != pattern[j]) {
            j = next[j - 1];
        }
        if (text[i] == pattern[j]) {
            j++;
        }
        if (j == m) {
            return i - m + 1;
        }
    }
    return -1;
}
```
# 数据结构
## 线段树
```cpp

```